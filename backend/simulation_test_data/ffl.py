# based on code from http://be150.caltech.edu/2019/handouts/02_intro_to_python_for_biological_circuits.html 
# Results should look similar to the graph here: https://biocircuits.github.io/chapters/04_ffls.html#:~:text=gamma%20%3D%201-,kappa,-%3D%201%0An_xy 
import numpy as np
import scipy.integrate
import biocircuits
import bokeh.application
from   bokeh.io import output_file
import bokeh.plotting as bp

bokeh.io.output_notebook()

def x_pulse(t, t_0, t_f, tau, x_0, duty_cycle):
    """
    Returns x value for a pulse beginning at t = t_0 with a period of tau. 
    duty_cycle is the fraction of the period that the pulse is on. This should be between 0 and 1.
    x_0 is the amplitude of the pulse.
    t_f is when the pulse should stop.
    """
    # Find how far into the current period we are. Use floor to support floating point values.
    t_since_period_start = t - t_0 - ((t - t_0) // (tau))*(tau)

    return np.logical_and(t >= t_0, np.logical_and(t <= t_f, t_since_period_start <= tau*duty_cycle)) * x_0


# Simulates a basic feed forward loop in which x activates y and z, and y activates z. x and y are both needed for z to go high.
# y slowly activates z, while x quickly activates z. This makes the output z resistant to noise in x.
def feed_forward_loop(xyz, t, n_xy, n_yz, n_xz, gamma, x_fun, x_args):
    # Compute x
    x = x_fun(t, *x_args) # if x is generated by the circuit as well, we must define this as x_user and have another variable for x_circuit

    # Unpack x, y and z
    _, y, z = xyz

    # Compute dy/dt and dz/dt
    dy_dt = biocircuits.act_hill(x, n_xy) - gamma*y
    dz_dt = biocircuits.aa_and(x, y, n_xz, n_yz) - gamma*z
    
    # Return the result as a NumPy array
    return np.array([0, dy_dt, dz_dt])

# Number of time points we want for the solutions
n = 1000

# Time points
t = np.linspace(0, 20, n)

# Initial concentrations of y and z
xyz_0 = np.array([0.0, 0.0, 0.0])

# Parameters
n_xy = 3
n_yz = 3
n_xz = 3
gamma = 1

# Set up parameters for the pulse
x_args = (0, 2, 2, 1.0, 0.5)

# Set up parameters for feed forward loop function
args = (n_xy, n_yz, n_xz, gamma, x_pulse, x_args)

# Call solver
xyz_concentrations = scipy.integrate.odeint(feed_forward_loop, xyz_0, t, args=args)

# Add x values to the concentrations
x_vals = x_pulse(t, *x_args)
# Combine x, y, z values into a single array
xyz_concentrations[:, 0] = x_vals

# log concentrations
with open("ffl_short_results.txt", "w") as f:
    np.savetxt(f, xyz_concentrations, comments='')

xyz_concentrations.shape

# Repeat with long pulse:
# Set up parameters for the pulse
x_args = (0, 15, 20, 1.0, 0.5)

args = (n_xy, n_yz, n_xz, gamma, x_pulse, x_args)

# Call solver
xyz_concentrations = scipy.integrate.odeint(feed_forward_loop, xyz_0, t, args=args)
# Add x values to the concentrations
x_vals = x_pulse(t, *x_args)
# Combine x, y, z values into a single array
xyz_concentrations[:, 0] = x_vals

# log concentratoins
with open("ffl_long_results.txt", "w") as f:
    np.savetxt(f, xyz_concentrations, comments='')
