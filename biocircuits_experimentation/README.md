## Overview

These experimental programs use the [biocircuits python library](https://biocircuits.github.io/package_docs/index.html) to simulate cellular behavior. Currently, there is just one program (ffl_biocircuit.py) which simulates a feed forward loop.

- [Setup steps](#setup-steps)
- [Differential equation solver](#scipy-odeint)
- [Pulse input function](#pulse-input-function)
- [Feed forward loop]()
- [Hill coefficients](#hill-coefficients)
- [Future work](#future-work)
- [Areas of ambiguity](#areas-of-ambiguity)

### Setup Steps
Required SW:
- biocircuits
    - See [installation steps and dependencies](https://biocircuits.github.io/package_docs/getting_started/installation.html)
- bokeh (version 3.x)
- numpy
- scipy.integrate

### Differential Equation Solver
The current program uses scipy.integrate.odeint to calculate the concentrations of each protein for a certain set of times. You can read more about scipy.integrate.odeint [here](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.odeint.html)

The odeint function takes a function and an array of initial concentrations as its first two args. This function must return the production rate of each protein. Thus, the size of the array returned by this function argument must match the size of the array that specifies the initial concentrations of each protein. odeint repeatedly calls the provided function, and updates the current concentrations of each protein based on the returned production rates.

For a given protein, the production rate can be calculated using the [biocircuit regulatory functions](https://biocircuits.github.io/package_docs/user_guide/api.html#regulatory-functions). These functions assume no leakage, so for now I have manually added in an arbitrary leakage coefficient for the feed forward loop script (ffl_biocircuit.py).

The production rate can also be governed by user input. We still need to determine the interface for this. However, as demonstrated in ffl_biocircuit.py, we can pass in a separate function to manually control the concentration of a protein.

*Note: sometimes this solver is not responsive when the signal remains constant for a while. This is due to an optimization of the solver. The problem and a solution are described [here](http://be150.caltech.edu/2019/handouts/02_intro_to_python_for_biological_circuits.html#Really-short-pulses-and-a-lesson-about-scipy.integrate.odeint()).

### Pulse Input Function
In ffl_biocircuit.py I defined a pulse function that takes as arguments the current time (t), the time the pulse should start (t_0), the time it should end (t_f), the period of the pulse (tau), the amplitude of the pulse (x_0), and the duty cycle (duty_cycle). The duty cycle is the ratio of the time the pulse is high to the pulse period. So a pulse with a duty cycle of 0.5 is ON half of the time. 

We can retreive these parameters from the user, to allow for any possible pulse signal they want to simulate.

### Feed Forward Loop
A feed forward loop is a standard genetic circuit component ([explained here](https://www.youtube.com/watch?v=AwXGNYYHoUM)) in which some input X activates some output Z. To make Z resistant to noise, we add an intermediate protein Y. Both X and Y must be activating Z for Z to be fully activated (i.e. Z = X AND Y). X activates both Z and Y quickly. Y activates Z slowly. 

I attempted to simulate this circuit in ffl_biocircuit.py. I started with a generic example based on the program outlined [here](http://be150.caltech.edu/2019/handouts/02_intro_to_python_for_biological_circuits.html#2.-Introduction-to-Python-for-biological-circuits), then I changed the logic to mimic a FFL. The plots generated by this script resemble the plots shown in [this youtube video on FFLs](https://www.youtube.com/watch?v=AwXGNYYHoUM). We keep everything the same and simply change the duty cycle. The final output Z does not respond on a short pulse, but does respond on a long pulse.

### Hill Coefficients
Hill coefficients are inputs to the biocircuits regulatory functions. They determine the cooperativity of a protein. I need to do more research to fully understand what that means. A hill coefficient of 1 means that each ligand binds independently. A hill coefficient > 1 means that the binding of one ligand increases the likelihood of another ligand binding. A hill coefficient of < 1 means it decreases the likelihood.

In ffl_biocircuit.py I set n_y (the hill coefficient of protein Y) equal to 4. I did this because the resulting graph mimicked what is expected of a FFL. However, I don't this this is the mechanism we should be using for controlling how quickly one protein impacts the production of another.

### Future Work
We need to extend this basic setup to support a multi-level circuit that is determined at runtime. I think we should:
- Create a "Protein" class which contains
    - A function that returns the protein's production rate
    - The protein's ID (or enum)
    - The protein's initial concentration
    - A set of logical gates and their inputs
    - The protein's hill coefficient
- The production rate function of this object is the most complicated part of the simulator. To calculate the effective production rate we must take into account:
    - The set of logical gates
    - The current concentrations of the proteins that are inputs to those gates
    - The hill coefficients of those proteins
    - The user defined function for the concentration of this protein (if this protein is an input stimulus of the circuit)
- The function that we pass into odeint will compute and return the production rates by calling the production rate calculator on each protein in the circuit

### Areas of ambiguity
- Users must specify input stimuli behavior
    -  We need to finalize how flexible and fine-grained this mechanism should be. 
    - In my opinion, we should at least allow for a pulse mode and a steady state mode. Ideally, we would also allow them to specify a continuous concentration function of time.
- "Interfering" concentration sources
    - We need to support looping logic — meaning that a protein's effective production rate may be impacted by several gates in different parts of the circuit
    - We must also account for the case that the input stimuli (say, protein X) is produced as an output later on in the circuit. We could handle this case by "merging" (a.k.a. summing) the concentrations. In other words, we can store separate x_user_defined, x_circuit_defined, and x_effective concentrations. 
- Tailoring influence of one protein on another
    - As I brushed upon earlier, in some cases we want to be able to dictate the influence of one protein on another's production. 
    - In a FFL, protein X quickly actiavates Z, while Y slowly activates Z. 
    - It does not appear the biocircuits supports this specialized behavior, so we will likely need to emulate it manually.
