# based on code from http://be150.caltech.edu/2019/handouts/02_intro_to_python_for_biological_circuits.html 
import numpy as np
import scipy.integrate
import biocircuits
import bokeh.application
from   bokeh.io import output_file
import bokeh.plotting as bp

bokeh.io.output_notebook()

def x_pulse(t, t_0, t_f, tau, x_0, duty_cycle):
    """
    Returns x value for a pulse beginning at t = t_0 with a period of tau. 
    duty_cycle is the fraction of the period that the pulse is on. This should be between 0 and 1.
    x_0 is the amplitude of the pulse.
    t_f is when the pulse should stop.
    """
    # Find how far into the current period we are. Use floor to support floating point values.
    t_since_period_start = t - t_0 - ((t - t_0) // (tau))*(tau)

    return np.logical_and(t >= t_0, np.logical_and(t <= t_f, t_since_period_start <= tau*duty_cycle)) * x_0


# Simulates a basic feed forward loop in which x activates y and z, and y activates z. x and y are both needed for z to go high.
# y slowly activates z, while x quickly activates z. This makes the output z resistant to noise in x.
def feed_forward_loop(yz, t, n_x, n_y, x_fun, x_args):
    # Compute x
    x = x_fun(t, *x_args) # if x is generated by the circuit as well, we must define this as x_user and have another variable for x_circuit

    # Unpack x, y and z
    y, z = yz

    # Compute dy/dt and dz/dt
    # TODO: figure out rate of degredation
    dy_dt = biocircuits.act_hill(x, n_x) - 0.05*y
    dz_dt = biocircuits.aa_and(x, y, n_x, n_y) - 0.05*z
    
    # Return the result as a NumPy array
    return np.array([dy_dt, dz_dt])

# Number of time points we want for the solutions
n = 1000

# Time points
t = np.linspace(0, 20, n)

# Initial concentrations of y and z
yz_0 = np.array([0.0, 0.0])

# Parameters
n_x = 1 # x is the input stimulus
# TODO: we need to find a way to adjust the strength of the activation and repression. For now, manually change hill coefficient to mimic FFL behavior
n_y = 4 # z responds to y slowly

# Set up parameters for the pulse
x_args = (3.0, 19.0, 5.0, 2.0, 0.2)

# Set up parameters for feed forward loop function
args = (n_x, n_y, x_pulse, x_args)

# Call solver
yz_concentrations = scipy.integrate.odeint(feed_forward_loop, yz_0, t, args=args)

yz_concentrations.shape

# Set up color palette
colors = bokeh.palettes.d3['Category10'][10]
# Pluck out x, y and z
y, z = yz_concentrations.transpose()
# Set up plot
p = bp.figure(width=500,
                          height=300,
                          x_axis_label='dimensionless time',
                          y_axis_label='dimensionless y, z')

# Populate glyphs
p.line(t, y, line_width=2, color=colors[1], legend_label='y')
p.line(t, z,line_width=2, color=colors[2], legend_label='z')

# Place the legend
p.legend.location = 'bottom_right'

# Plot the pulse TODO: is there a way to do this without re-calling the pulse function?
p_x = bp.figure(width=500,
                          height=300,
                          x_axis_label='dimensionless time',
                          y_axis_label='dimensionless x')

# Populate glyphs
p_x.line(t, x_pulse(t, 3.0, 19.0, 5.0, 2.0, 0.2), line_width=2)

#Show plot
output_file("plots/ffl_short_pulse_plot.html")
layout = bokeh.layouts.column(p, p_x)
bokeh.io.show(layout)

# Repeat with long pulse:
# Set up parameters for the pulse
x_args = (3.0, 19.0, 5.0, 2.0, 0.5) # the only change is the duty cycle

args = (n_x, n_y, x_pulse, x_args)

# Call solver
yz_concentrations = scipy.integrate.odeint(feed_forward_loop, yz_0, t, args=args)

yz_concentrations.shape

# Set up color palette
colors = bokeh.palettes.d3['Category10'][10]
# Pluck out x, y and z
y, z = yz_concentrations.transpose()
# Set up plot
p = bp.figure(width=500,
                          height=300,
                          x_axis_label='dimensionless time',
                          y_axis_label='dimensionless y, z')

# Populate glyphs
p.line(t, y, line_width=2, color=colors[1], legend_label='y')
p.line(t, z,line_width=2, color=colors[2], legend_label='z')

# Place the legend
p.legend.location = 'bottom_right'

# Plot the pulse
p_x = bp.figure(width=500,
                          height=300,
                          x_axis_label='dimensionless time',
                          y_axis_label='dimensionless x')

# Populate glyphs
p_x.line(t, x_pulse(t, 3.0, 19.0, 5.0, 2.0, 0.5), line_width=2)

#Show plot
output_file("plots/ffl_long_pulse_plot.html")
layout = bokeh.layouts.column(p, p_x)
bokeh.io.show(layout)